package com.github.zhangruiyu.flutterjsonbeanfactory.action.dart_to_helper

import com.github.zhangruiyu.flutterjsonbeanfactory.action.migrate.MigrateOldProject
import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.PlatformDataKeys
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.application.runWriteAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.newvfs.impl.VirtualFileImpl
import com.github.zhangruiyu.flutterjsonbeanfactory.file.FileHelpers
import com.github.zhangruiyu.flutterjsonbeanfactory.utils.YamlHelper
import com.github.zhangruiyu.flutterjsonbeanfactory.utils.commitContent
import com.github.zhangruiyu.flutterjsonbeanfactory.workers.FileGenerator
import com.github.zhangruiyu.flutterjsonbeanfactory.utils.showNotify
import io.flutter.pub.PubRoot
import java.io.File
import java.lang.RuntimeException

class FlutterBeanFactoryAction : AnAction() {

    override fun actionPerformed(e: AnActionEvent) {
        generateAllFile(e.getData(PlatformDataKeys.PROJECT)!!)

    }

    companion object {

        private val indent = FileHelpers.indent
        /**
         * 生成辅助类
         */
        fun generateAllFile(project: Project) {
            val pubSpecConfig = YamlHelper.getPubSpecConfig(project)
            //判断是否是flutter项目
            if (YamlHelper.shouldActivateFor(project)) {
                try {
                    MigrateOldProject.getAllEntityFiles(project)
                    //如果没有可以生成的文件,那么就不会生成
                    val allClass = FileHelpers.getAllEntityFiles(project)
                    if (allClass.isEmpty()) {
                        throw RuntimeException("No classes that inherit JsonConvert were found,the project root directory must contain the lib directory, because this plugin will only scan the lib directory of the root directory")
                    }
                    ApplicationManager.getApplication().invokeLater {
                        runWriteAction {
                            FileGenerator(project).generate()
                        }
                    }
                    FileHelpers.getGeneratedFileRun(project) {
                        //1.上次生成的老旧老文件
                        val oldHelperChildren =
                            it.children.filterIsInstance<VirtualFileImpl>().toMutableList()
                        //2.删除多余helper文件
                        oldHelperChildren.forEach { oldPath ->
                            //新生成的文件名
                            val newFileNameList =
                                allClass.map { newPath -> "${File(newPath.second).nameWithoutExtension}.g.dart" }
                            //如果现在生成的不包含在这里,那么就删除
                            if (newFileNameList.contains(oldPath.name).not()) {
                                oldPath.delete(oldPath)
                            }
                        }
                        //3.重新生成所有helper类
                        FileHelpers.generateAllDartEntityHelper(project, allClass)
                        //4.重新生成jsonConvert类
                        val content = StringBuilder()
                        content.append("// ignore_for_file: non_constant_identifier_names\n// ignore_for_file: camel_case_types\n// ignore_for_file: prefer_single_quotes\n\n")
                        content.append("// This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n")
                        content.append("import 'package:flutter/material.dart';\n")
                        //导包
                        allClass.forEach { itemNeedFile ->
                            content.append(itemNeedFile.second)
                            content.append("\n")
                        }

                        content.append("\n")

                        ////
                        content.append("JsonConvert jsonConvert = JsonConvert();")
                        content.append("\n\n")
                        content.append("typedef JsonConvertFunction<T> = T Function(Map<String, dynamic> json);")
                        content.append("\n\n")
                        content.append("class JsonConvert {")
                        content.append("\n")
                        content.append("${indent}static final Map<String, JsonConvertFunction> _convertFuncMap = {")
                        content.append("\n")
                        allClass.forEach { itemClass ->
                            itemClass.first.classes.forEach { itemFile ->
                                content.append("${indent}${indent}(${itemFile.className}).toString(): ${itemFile.className}.fromJson,\n")
                            }
                        }
                        content.append("${indent}};")
                        content.append("\n\n")
                        content.append(
                            "  T? convert<T>(dynamic value) {\n" +
                                    "    if (value == null) {\n" +
                                    "      return null;\n" +
                                    "    }\n" +
                                    "    return asT<T>(value);\n" +
                                    "  }"
                        )
                        content.append("\n\n")
                        content.append(
                            "  List<T?>? convertList<T>(List<dynamic>? value) {\n" +
                                    "    if (value == null) {\n" +
                                    "      return null;\n" +
                                    "    }\n" +
                                    "    try {\n" +
                                    "      return value.map((dynamic e) => asT<T>(e)).toList();\n" +
                                    "    } catch (e, stackTrace) {\n" +
                                    "      debugPrint('asT<${"\$T"}> ${"\$e"} ${"\$stackTrace"}');\n" +
                                    "      return <T>[];\n" +
                                    "    }\n" +
                                    "  }"
                        )
                        content.append("\n\n")
                        content.append(
                            "  List<T>? convertListNotNull<T>(dynamic value) {\n" +
                                    "    if (value == null) {\n" +
                                    "      return null;\n" +
                                    "    }\n" +
                                    "    try {\n" +
                                    "      return (value as List<dynamic>).map((dynamic e) => asT<T>(e)!).toList();\n" +
                                    "    } catch (e, stackTrace) {\n" +
                                    "      debugPrint('asT<${"\$T"}> ${"\$e"} ${"\$stackTrace"}');\n" +
                                    "      return <T>[];\n" +
                                    "    }\n" +
                                    "  }"
                        )
                        content.append("\n\n")
                        content.append(
                            "  T? asT<T extends Object?>(dynamic value) {\n" +
                                    "    if (value is T) {\n" +
                                    "      return value;\n" +
                                    "    }\n" +
                                    "    final String type = T.toString();\n" +
                                    "    try {\n" +
                                    "      final String valueS = value.toString();\n" +
                                    "      if (type == \"String\") {\n" +
                                    "        return valueS as T;\n" +
                                    "      } else if (type == \"int\") {\n" +
                                    "        final int? intValue = int.tryParse(valueS);\n" +
                                    "        if (intValue == null) {\n" +
                                    "          return double.tryParse(valueS)?.toInt() as T?;\n" +
                                    "        } else {\n" +
                                    "          return intValue as T;\n" +
                                    "        }\n" +
                                    "      } else if (type == \"double\") {\n" +
                                    "        return double.parse(valueS) as T;\n" +
                                    "      } else if (type == \"DateTime\") {\n" +
                                    "        return DateTime.parse(valueS) as T;\n" +
                                    "      } else if (type == \"bool\") {\n" +
                                    "        if (valueS == '0' || valueS == '1') {\n" +
                                    "          return (valueS == '1') as T;\n" +
                                    "        }\n" +
                                    "        return (valueS == 'true') as T;\n" +
                                    "      } else if (type == \"Map\" || type.startsWith(\"Map<\")) {\n" +
                                    "        return value as T;\n" +
                                    "      } else {\n" +
                                    "        if (_convertFuncMap.containsKey(type)) {\n" +
                                    "          return _convertFuncMap[type]!(value) as T;\n" +
                                    "        } else {\n" +
                                    "          throw UnimplementedError('${"\$type"} unimplemented');\n" +
                                    "        }\n" +
                                    "      }\n" +
                                    "    } catch (e, stackTrace) {\n" +
                                    "      debugPrint('asT<${"\$T"}> ${"\$e"} ${"\$stackTrace"}');\n" +
                                    "      return null;\n" +
                                    "    }\n" +
                                    "  }"
                        )
                        //_getListFromType
                        content.append("\n\n")
                        content.append(
                            "${indent}//list is returned by type\n" +
                                    "${indent}static M? _getListChildType<M>(List<Map<String, dynamic>> data) {\n"
                        )
                        allClass.forEach { itemClass ->
                            itemClass.first.classes.forEach { itemFile ->
                                content.append("${indent}${indent}if(<${itemFile.className}>[] is M){\n")
                                content.append("${indent}${indent}${indent}return data.map<${itemFile.className}>((Map<String, dynamic> e) => ${itemFile.className}.fromJson(e)).toList() as M;\n")
                                content.append("${indent}${indent}}\n")
                            }
                        }
                        content.append(
                            "\n${indent}${indent}debugPrint(\"\${M.toString()} not found\");\n${indent}"
                        )
                        content.append(
                            "\n${indent}${indent}return null;\n}"
                        )
                        content.append("\n\n")
                        //fromJsonAsT
                        content.append(
                            "${indent}static M? fromJsonAsT<M>(dynamic json) {\n" +
                                    "${indent}${indent}if (json is List) {\n" +
                                    "${indent}${indent}${indent}return _getListChildType<M>(json.map((e) => e as Map<String, dynamic>).toList());\n" +
                                    "${indent}${indent}} else {\n" +
                                    "${indent}${indent}${indent}return jsonConvert.asT<M>(json);\n" +
                                    "${indent}${indent}}\n" +
                                    "${indent}}"
                        )

                        content.append("\n")
                        content.append("}")
                        content.append("\n")
                        val generated = FileHelpers.getJsonConvertBaseFile(project)
                        //获取json_convert_content目录,并写入
                        generated.findOrCreateChildData(this, "json_convert_content.dart")
                            .commitContent(project, content.toString())

                        project.showNotify("convert factory is generated")
                    }
                } catch (e: RuntimeException) {
                    e.printStackTrace()
                    e.message?.let { project.showNotify(it) }
                }


            } else {
                project.showNotify("This project is not the flutter project")
            }


        }
    }
}
